//! Effects that rules can produce.
//!
//! Effects are the actions taken when a rule fires. Effects can be:
//! - Simple built-in operations (EmitMessage)
//! - VM-executed scripts (Script variant with S-expression)
//!
//! ## Script Effects
//!
//! Script effects store an S-expression that is compiled and executed
//! via the VM. This allows arbitrary bytecode execution including:
//! - `(say "message")` - output messages
//! - `(set! entity :component value)` - modify components
//! - `(relate! :relation from to)` - create relations
//! - `(destroy! entity)` - remove entities
//!
//! Example:
//! ```ignore
//! let effect = Effect::script(Value::list(vec![
//!     Value::Symbol(Symbol::new("say")),
//!     Value::string("The goat says: Baa!"),
//! ]));
//! ```

use crate::compiler::Compiler;
use crate::core::{EntityId, Value, World};
use crate::io::WorldIO;
use crate::lang::{Atom, SExpr, Span};
use crate::symbol::Symbol;
use crate::vm::{ActionContext, PendingMutations, StdLib, VM};

/// An action taken when a rule fires.
#[derive(Debug, Clone)]
pub enum Effect {
    /// Execute a VM script (S-expression that gets compiled and run).
    ///
    /// The script has access to:
    /// - `(actor)` - the matched entity
    /// - `(say "msg")` - output messages
    /// - `(set! entity :comp value)` - modify components
    /// - Standard library functions
    Script(Value),

    /// No-op effect (for rules that only need pattern matching).
    NoOp,
}

/// Result of executing a script effect.
#[derive(Debug, Clone, Default)]
pub struct EffectResult {
    /// Output messages generated by the effect.
    pub output: Vec<String>,
    /// Pending mutations to apply to the world.
    pub mutations: PendingMutations,
}

impl Effect {
    /// Create a Script effect that emits a message.
    ///
    /// This is a convenience method that creates `(say "message")`.
    pub fn emit_message(message: impl Into<String>) -> Self {
        let msg = message.into();
        Effect::Script(Value::list(vec![
            Value::Symbol(Symbol::new("say")),
            Value::string(msg),
        ]))
    }

    /// Create a Script effect from an S-expression.
    pub fn script(expr: Value) -> Self {
        Effect::Script(expr)
    }

    /// Create a no-op effect.
    pub fn no_op() -> Self {
        Effect::NoOp
    }

    /// Execute this effect (legacy interface for backward compatibility).
    ///
    /// The `entity` parameter is the entity that matched the rule's pattern.
    /// The `tick` is the current simulation tick.
    ///
    /// Note: For Script effects, this uses default StdLib. Use `execute_with_context`
    /// for full control over execution context.
    pub fn execute(&self, world: &World, io: &mut dyn WorldIO, entity: EntityId, tick: u64) {
        match self {
            Effect::Script(expr) => {
                let stdlib = StdLib::with_builtins();
                let context = ActionContext {
                    actor: entity,
                    direct_object: None,
                    indirect_object: None,
                    room: None,
                };
                match execute_script_effect(world, expr, &context, &stdlib) {
                    Ok(result) => {
                        for msg in result.output {
                            io.println(&format!("[Tick {tick}] {msg}"));
                        }
                        // Note: mutations are dropped in legacy interface
                        // Use execute_with_context for mutation support
                    }
                    Err(e) => {
                        io.println(&format!("[Tick {tick}] Effect error: {e}"));
                    }
                }
            }
            Effect::NoOp => {}
        }
    }

    /// Execute this effect with full context, returning result and mutations.
    ///
    /// This is the preferred interface for new code.
    pub fn execute_with_context(
        &self,
        world: &World,
        context: &ActionContext,
        stdlib: &StdLib,
        _tick: u64,
    ) -> Result<EffectResult, EffectError> {
        match self {
            Effect::Script(expr) => execute_script_effect(world, expr, context, stdlib),
            Effect::NoOp => Ok(EffectResult::default()),
        }
    }

    /// Get a human-readable description of this effect.
    pub fn describe(&self) -> String {
        match self {
            Effect::Script(expr) => format!("script {expr}"),
            Effect::NoOp => "no-op".to_string(),
        }
    }

    /// Check if this effect is a script.
    pub fn is_script(&self) -> bool {
        matches!(self, Effect::Script(_))
    }

    /// Get the script expression if this is a Script effect.
    pub fn as_script(&self) -> Option<&Value> {
        match self {
            Effect::Script(expr) => Some(expr),
            _ => None,
        }
    }
}

/// Error from effect execution.
#[derive(Debug, Clone)]
pub enum EffectError {
    /// Compilation error.
    CompileError(String),
    /// Runtime error.
    RuntimeError(String),
    /// Invalid value error.
    InvalidValue(String),
}

impl std::fmt::Display for EffectError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EffectError::CompileError(msg) => write!(f, "compile error: {msg}"),
            EffectError::RuntimeError(msg) => write!(f, "runtime error: {msg}"),
            EffectError::InvalidValue(msg) => write!(f, "invalid value: {msg}"),
        }
    }
}

impl std::error::Error for EffectError {}

/// Execute a script effect via the VM.
fn execute_script_effect(
    world: &World,
    expr: &Value,
    context: &ActionContext,
    stdlib: &StdLib,
) -> Result<EffectResult, EffectError> {
    // Wrap expression in (do ...) if it's not already a do-block
    let wrapped = wrap_in_do(expr);

    // Convert Value to SExpr for compiler
    let sexpr = value_to_sexpr(&wrapped)?;

    // Compile to bytecode
    let chunk = Compiler::compile(&sexpr).map_err(|e| EffectError::CompileError(e.to_string()))?;

    // Execute via VM with action context
    let mut vm = VM::new(&chunk, world, stdlib).with_action_context(context.clone());
    vm.run()
        .map_err(|e| EffectError::RuntimeError(e.to_string()))?;

    // Collect results
    let mutations = PendingMutations {
        set_components: vm.take_pending_set_components(),
        relate: vm.take_pending_relate(),
        unrelate: vm.take_pending_unrelate(),
        deletions: vm.take_pending_deletions(),
    };

    Ok(EffectResult {
        output: vm.take_output(),
        mutations,
    })
}

/// Convert a Value to SExpr for compilation.
fn value_to_sexpr(value: &Value) -> Result<SExpr, EffectError> {
    let span = Span::new(0, 0, 0, 0); // Dummy span for generated code

    match value {
        Value::Nil => Ok(SExpr::Atom(Atom::Nil, span)),
        Value::List(items) => {
            if items.is_empty() {
                Ok(SExpr::Atom(Atom::Nil, span))
            } else {
                let exprs: Result<Vec<_>, _> = items.iter().map(value_to_sexpr).collect();
                Ok(SExpr::List(exprs?, span))
            }
        }
        Value::Int(n) => Ok(SExpr::Atom(Atom::Int(*n), span)),
        Value::Float(f) => Ok(SExpr::Atom(Atom::Float(*f), span)),
        Value::Bool(b) => Ok(SExpr::Atom(Atom::Bool(*b), span)),
        Value::String(s) => Ok(SExpr::Atom(Atom::String(s.to_string()), span)),
        Value::Symbol(s) => Ok(SExpr::Atom(Atom::Symbol(*s), span)),
        Value::EntityRef(e) => {
            // Entity refs use a placeholder symbol
            Ok(SExpr::Atom(
                Atom::Symbol(Symbol::new(&format!("__entity_{}", e.raw()))),
                span,
            ))
        }
    }
}

/// Wrap expression in (do ...) if needed.
fn wrap_in_do(expr: &Value) -> Value {
    // If it's already a do-block, return as-is
    if let Value::List(items) = expr {
        if let Some(Value::Symbol(s)) = items.first() {
            if s.as_str() == "do" {
                return expr.clone();
            }
        }
    }

    // Wrap in (do expr)
    Value::list(vec![Value::Symbol(Symbol::new("do")), expr.clone()])
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::io::TestIO;

    #[test]
    fn test_emit_message_effect() {
        let world = World::new();
        let mut io = TestIO::new(vec![]);
        let entity = EntityId::from_raw(42);

        let effect = Effect::emit_message("Hello, world!");
        effect.execute(&world, &mut io, entity, 100);

        // emit_message now creates a Script effect with (say "...")
        assert!(io.output.contains("Hello, world!"));
        assert!(io.output.contains("Tick 100"));
    }

    #[test]
    fn test_effect_describe() {
        // emit_message now creates a Script effect
        let effect = Effect::emit_message("Baa!");
        let desc = effect.describe();
        assert!(desc.starts_with("script"));
        assert!(desc.contains("Baa!"));
    }

    #[test]
    fn test_script_effect_say() {
        let world = World::new();
        let mut io = TestIO::new(vec![]);
        let entity = EntityId::from_raw(42);

        // Create script effect: (say "The goat says: Baa!")
        let script = Value::list(vec![
            Value::Symbol(Symbol::new("say")),
            Value::string("The goat says: Baa!"),
        ]);
        let effect = Effect::script(script);

        effect.execute(&world, &mut io, entity, 100);

        assert!(io.output.contains("The goat says: Baa!"));
    }

    #[test]
    fn test_script_effect_with_context() {
        let world = World::new();
        let stdlib = StdLib::with_builtins();
        let entity = EntityId::from_raw(42);

        let context = ActionContext {
            actor: entity,
            direct_object: None,
            indirect_object: None,
            room: None,
        };

        // Create script effect with multiple expressions wrapped in do
        let script = Value::list(vec![
            Value::Symbol(Symbol::new("do")),
            Value::list(vec![
                Value::Symbol(Symbol::new("say")),
                Value::string("First message"),
            ]),
            Value::list(vec![
                Value::Symbol(Symbol::new("say")),
                Value::string("Second message"),
            ]),
        ]);
        let effect = Effect::script(script);

        let result = effect
            .execute_with_context(&world, &context, &stdlib, 100)
            .unwrap();

        assert_eq!(result.output.len(), 2);
        assert_eq!(result.output[0], "First message");
        assert_eq!(result.output[1], "Second message");
    }

    #[test]
    fn test_noop_effect() {
        let world = World::new();
        let mut io = TestIO::new(vec![]);
        let entity = EntityId::from_raw(42);

        let effect = Effect::no_op();
        effect.execute(&world, &mut io, entity, 100);

        assert!(io.output.is_empty());
    }

    #[test]
    fn test_effect_is_script() {
        // emit_message now creates a Script effect
        let emit = Effect::emit_message("test");
        assert!(emit.is_script());

        let script = Effect::script(Value::Int(42));
        assert!(script.is_script());

        let noop = Effect::no_op();
        assert!(!noop.is_script());
    }

    #[test]
    fn test_effect_as_script() {
        let value = Value::string("test");
        let script = Effect::script(value.clone());

        assert_eq!(script.as_script(), Some(&value));

        // emit_message now creates a Script effect, so as_script returns Some
        let emit = Effect::emit_message("test");
        assert!(emit.as_script().is_some());
    }

    #[test]
    fn test_script_effect_describe() {
        let script = Value::list(vec![
            Value::Symbol(Symbol::new("say")),
            Value::string("Hello"),
        ]);
        let effect = Effect::script(script);

        let desc = effect.describe();
        assert!(desc.starts_with("script"));
        assert!(desc.contains("say"));
    }

    #[test]
    fn test_wrap_in_do() {
        // Non-do expression gets wrapped
        let expr = Value::Int(42);
        let wrapped = wrap_in_do(&expr);
        let list = match &wrapped {
            Value::List(items) => items,
            _ => panic!("Expected list"),
        };
        match &list[0] {
            Value::Symbol(s) => assert_eq!(s.as_str(), "do"),
            _ => panic!("Expected symbol"),
        }

        // Do expression stays as-is
        let do_expr = Value::list(vec![
            Value::Symbol(Symbol::new("do")),
            Value::Int(1),
            Value::Int(2),
        ]);
        let wrapped_do = wrap_in_do(&do_expr);
        assert_eq!(wrapped_do, do_expr);
    }

    #[test]
    fn test_value_to_sexpr() {
        // Test simple values
        let int_sexpr = value_to_sexpr(&Value::Int(42)).unwrap();
        assert!(matches!(int_sexpr, SExpr::Atom(Atom::Int(42), _)));

        let string_sexpr = value_to_sexpr(&Value::string("hello")).unwrap();
        assert!(matches!(string_sexpr, SExpr::Atom(Atom::String(s), _) if s == "hello"));

        // Test list
        let list_value = Value::list(vec![
            Value::Symbol(Symbol::new("say")),
            Value::string("test"),
        ]);
        let list_sexpr = value_to_sexpr(&list_value).unwrap();
        assert!(matches!(list_sexpr, SExpr::List(_, _)));
    }
}
